[project]
# Basic project metadata
name = "cache_simulator"
dynamic = ["version"]
description = "A simulator for processor caches"
license = "MIT"
authors = [{ name = "Pavel Kravchenya", email = "kpdphys@example.com" }]
readme = "README.md"
requires-python = ">=3.13"

# Core runtime dependencies
dependencies = [
  "numpy (>=2.2.6,<3.0.0)",         # Fundamental package for array computing
  "torch (>=2.7.0,<3.0.0)",         # Tensors and Dynamic neural networks
  "PyYAML (>=6.0.2,<7.0.0)",        # YAML parser and emitter
  "dvc (>=3.59.2,<4.0.0)",          # Tool to manage code and data together
  "python-dotenv (>=1.1.0,<2.0.0)", # Set key-value pairs from a .env file
  "deepspeed (>=0.16.8,<1.0.0)",    # DeepSpeed library
  "mlflow (>=2.22.0,<3.0.0)",       # A platform for the complete ML lifecycle
  "dagshub (>=0.5.10,<1.0.0)",      # DagsHub client libraries
]

[tool.poetry]
# Static placeholder version
version = "0.0.0"

# Optional group of dependencies for special requirements (mpi, cuda, etc.)
[tool.poetry.group.special]
optional = true

[tool.poetry.group.special.dependencies]
causal-conv1d = ">=1.5.0,<2.0.0" # Causal depthwise conv1d in CUDA
mamba-ssm = ">=2.2.4,<3.0.0"     # Mamba state-space model
mpi4py = ">=4.0.3,<5.0.0"        # Python bindings for MPI

# Optional group of development dependencies
[tool.poetry.group.dev]
optional = true

[tool.poetry.group.dev.dependencies]
ruff = ">=0.11.10,<1.0.0"                    # Python linter and code formatter
mypy = ">=1.15.0,<2.0.0"                     # Optional static typing for Python
pytest = ">=8.3.5,<9.0.0"                    # A powerful testing framework
pytest-mock = ">=3.14.0,<4.0.0"              # Mocking for pytest
coverage = ">=7.8.1,<8.0.0"                  # Code coverage measurement tool
pytest-cov = ">=6.1.1,<7.0.0"                # Pytest plugin for coverage.py integration
bandit = ">=1.8.3,<2.0.0"                    # Security oriented static analyser
pre-commit = ">=4.2.0,<5.0.0"                # Pre-commit hook management
detect-secrets = ">=1.5.0,<2.0.0"            # Tool for detecting secrets in the codebase
python-semantic-release = ">=9.21.1,<10.0.0" # Automatic Semantic Versioning

[build-system]
# Poetry-specific build backend
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.pytest.ini_options]
# Minimum required version of pytest
minversion = "8.0"

# Additional command-line options:
# -rA : show extra test summary info for all outcomes (failing, skipped, etc.)
# -q  : quiet mode (less verbose output)
# -v  : verbose mode (increases verbosity, shows detailed test names and outcomes)
addopts = "-ra -q -v"

[tool.semantic_release]
# Use commit messages (Conventional Commits) to determine the next version.
version_source = "commit"

# Automatically update the version in pyproject.toml at the specified location.
version_variable = "pyproject.toml:version"

# Format used to create git tags for new releases.
tag_format = "v{version}"

# The branch where releases should be made.
branch = "main"

# The file where generated changelog entries from commits will be written.
changelog_file = "CHANGELOG.md"

# The command that builds your project before publishing (optional).
# build_command = "poetry build"

# Disable uploading to PyPI. Set to true if you want to publish the package.
upload_to_pypi = false

[tool.mypy]
# Target Python version for type checking
python_version = "3.13"

# Specify which files to check. This ensures that mypy 
# only checks .py and .pyi files at any depth in the project
files = "**/*.py,**/*.pyi"

# Enable all strict checks
strict = true

# Ignore imports that can't be resolved
ignore_missing_imports = false

# Disallow functions without type annotations
disallow_untyped_defs = true

# Disallow use of untyped imported values
disallow_any_unimported = true

# Warn when returning a value of type `Any`
warn_return_any = true

# Warn if `# type: ignore` comments are unused
warn_unused_ignores = true

[tool.bandit.assert_used]
# Skip assert checks (B101) in test files,
# where usage of "assert" is expected and acceptable
skips = ["*/test_*.py", "*/*_test.py", "tests/*", "*/tests/*"]

[tool.ruff]
# Specify file types to check
extend-include = ["*.py", "*.pyi"]

# Set length of code strings
line-length = 100

[tool.ruff.lint]
# Enable specific rules
select = [
  "F",  # Flake8 rules (unused imports, etc.)
  "D",  # Pydocstyle rules (documentation)
  "PT", # Pytest style
  "I",  # Import sorting (isort)
  "E",  # Code style (pycodestyle errors)
  "W",  # Style warnings (pycodestyle warnings)
  "B",  # Bug detection (flake8-bugbear)
]

# Ignore specific rules if needed
ignore = [
  "D211", # no-blank-line-before-class
  "D213", # multi-line-summary-second-line
]

[tool.coverage.run]
# Measure branch coverage in addition to statement coverage
branch = true

# Disable .coverage file
data_file = "/tmp/coverage_data"

# Omit test files and virtual environments from coverage measurement
omit = ["*/tests/*", "*/test_*.py", "*/*_test.py", "*/venv/*", "*/.venv/*"]

[tool.coverage.report]
# Fail if total coverage percentage is below 80%
fail_under = 80

# Regexes for lines to exclude from consideration
exclude_also = [
  # Don't complain about missing debug-only code:
  "def __repr__",
  "if self\\.debug",

  # Don't complain if tests don't hit defensive assertion code:
  "raise AssertionError",
  "raise NotImplementedError",

  # Don't complain if non-runnable code isn't run:
  "if 0:",
  "if __name__ == .__main__.:",

  # Don't complain about abstract methods, they aren't run:
  "@(abc\\.)?abstractmethod",
]

#
